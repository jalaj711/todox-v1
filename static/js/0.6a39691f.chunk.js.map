{"version":3,"sources":["database.js"],"names":["db","databasename","this","request","window","indexedDB","open","onsuccess","evt","isNew","then","todo_template","forEach","name","instance","default","TodoList","add","id","e","console","error","target","result","warn","log","onerror","errorCode","onupgradeneeded","objectStores","lists","createObjectStore","keyPath","tasks","meta","createIndex","unique","objectStore","data","transaction","onerrror","oncomplete","objStore","delete","get","newData","put","index","value","getAll","key","limit","store","matched","openCursor","cursor","push","length","continue","matches","ref","filter","val","test"],"mappings":"mIAAMA,E,WAOJ,WAAYC,GAAe,IAAD,2BAExBA,EAAeA,GAAgB,WAG/BC,KAAKC,QAAUC,OAAOC,UAAUC,KAAKL,GAGrCC,KAAKC,QAAQI,UAAY,SAAAC,GACvB,GAAI,EAAKC,MACP,IAOE,8BAA0BC,MAAK,SAAAC,GAC5B,CAAC,QAAS,QAAS,WAAY,QAAQC,SAAQ,SAAAC,GAC9C,IAAIC,EAAW,IAAIH,EAAcI,QAAQC,SACvCH,GACA,WACE,EAAKI,IAAI,QAASH,KAEpB,CAAEI,GAAIL,UAIZ,MAAOM,GACPC,QAAQC,MAAMF,GAGlB,EAAKnB,GAAKQ,EAAIc,OAAOC,OACrB,IACE,EAAKhB,UAAUC,GACf,MAAOW,GACPC,QAAQI,KAAKL,GACbC,QAAQK,IAAI,qCAGhBvB,KAAKC,QAAQuB,QAAU,SAAAlB,GACrB,IACE,EAAKkB,QAAQlB,GACb,MAAOW,GACPC,QAAQI,KAAKL,GACbC,QAAQK,IAAI,8BAAgC,EAAKtB,QAAQwB,aAG7DzB,KAAKC,QAAQyB,gBAAkB,SAAApB,GAC7B,EAAKR,GAAKQ,EAAIc,OAAOC,OACrB,EAAKM,aAAe,GACpB,EAAKpB,OAAQ,EAGb,EAAKoB,aAAaC,MAAQ,EAAK9B,GAAG+B,kBAAkB,QAAS,CAC3DC,QAAS,OAEX,EAAKH,aAAaI,MAAQ,EAAKjC,GAAG+B,kBAAkB,QAAS,CAC3DC,QAAS,OAEX,EAAKH,aAAaK,KAAO,EAAKlC,GAAG+B,kBAAkB,QAGnD,EAAKF,aAAaC,MAAMK,YAAY,OAAQ,OAAQ,CAAEC,QAAQ,IAC9D,EAAKP,aAAaI,MAAME,YAAY,SAAU,SAAU,CAAEC,QAAQ,IAClE,EAAKP,aAAaI,MAAME,YAAY,SAAU,SAAU,CAAEC,QAAQ,IAClE,EAAKP,aAAaI,MAAME,YAAY,UAAW,UAAW,CACxDC,QAAQ,K,gDAgBVC,EAAaC,EAAMZ,EAASnB,GAC9B,IAAIgC,EAAcrC,KAAKF,GAAGuC,YAAY,CAACF,GAAc,aAOrD,OANAE,EAAYC,SACVd,GAAY,SAAAlB,GAAG,OAAIY,QAAQK,IAAI,6BAA+BjB,IAChE+B,EAAYE,WACVlC,GAAc,SAAAC,GAAG,OAAIY,QAAQK,IAAI,6BAA+BjB,IAG3D+B,EAAYF,YAAYA,GAAapB,IAAIqB,K,6BAc3CI,EAAUxB,EAAIQ,EAASnB,GAC5B,IAAIgC,EAAcrC,KAAKF,GAAGuC,YAAY,CAACG,GAAW,aAOlD,OANAH,EAAYC,SACVd,GAAY,SAAAlB,GAAG,OAAIY,QAAQK,IAAI,gCAAkCjB,IACnE+B,EAAYE,WACVlC,GAAc,SAAAC,GAAG,OAAIY,QAAQK,IAAI,6BAA+BjB,IAG3D+B,EAAYF,YAAYK,GAAUC,OAAOzB,K,0BAY9CwB,EAAUxB,EAAIQ,EAASnB,GACzB,IAAIgC,EAAcrC,KAAKF,GAAGuC,YAAY,CAACG,GAAW,aAOlD,OANAH,EAAYC,SACVd,GAAY,SAAAlB,GAAG,OAAIY,QAAQK,IAAI,6BAA+BjB,IAChE+B,EAAYE,WACVlC,GAAc,SAAAC,GAAG,OAAIY,QAAQK,IAAI,6BAA+BjB,IAG3D+B,EAAYF,YAAYK,GAAUE,IAAI1B,K,6BAexCwB,EAAUxB,EAAI2B,EAAStC,EAAWmB,GACvC,IAAIa,EAAcrC,KAAKF,GAAGuC,YAAY,CAACG,GAAW,aAClDH,EAAYC,SACVd,GAAY,SAAAlB,GAAG,OAAIY,QAAQK,IAAI,gCAAkCjB,IACnE+B,EAAYE,WAAa,SAAAjC,GAAG,OAC1BY,QAAQK,IAAI,6BAA+BjB,IAE7C,IAAI6B,EAAcE,EAAYF,YAAYK,GAC1CL,EAAYO,IAAI1B,GAAIX,UAAY,SAAAC,GAC9B,IAAI8B,EAAO9B,EAAIc,OAAOC,OACtBe,EAAI,uCAAQA,GAASO,GAAjB,IAA0B3B,OAE9BmB,EAAYS,IAAIR,GAAM/B,UAAY,SAAAC,GAC5BD,GAAWA,EAAUC,O,iCAiBpBkC,EAAUK,EAAOC,EAAOtB,EAASnB,GAC1C,IAAIgC,EAAcrC,KAAKF,GAAGuC,YAAY,CAACG,GAAW,aAMlD,OALAH,EAAYC,SACVd,GAAY,SAAAlB,GAAG,OAAIY,QAAQK,IAAI,gCAAkCjB,IACnE+B,EAAYE,WACVlC,GAAc,SAAAC,GAAG,OAAIY,QAAQK,IAAI,6BAA+BjB,IAE3D+B,EAAYF,YAAYK,GAAUK,MAAMA,GAAOH,IAAII,K,oCAa9CN,EAAUK,EAAOC,EAAOzC,EAAWmB,GAC/C,IAAIa,EAAcrC,KAAKF,GAAGuC,YAAY,CAACG,GAAW,aAMlD,OALAH,EAAYC,SACVd,GAAY,SAAAlB,GAAG,OAAIY,QAAQK,IAAI,gCAAkCjB,IACnE+B,EAAYE,WACVlC,GAAc,SAAAC,GAAG,OAAIY,QAAQK,IAAI,6BAA+BjB,IAE3D+B,EAAYF,YAAYK,GAAUK,MAAMA,GAAOE,OAAOD,K,uCAiB9CN,EAAUQ,EAAKF,EAAOP,EAAYU,GACjD,IAAIC,EAAQlD,KAAKF,GAAGuC,YAAY,CAACG,IAAWL,YAAYK,GACpDW,EAAU,GAiBd,OAfAD,EAAME,aAAa/C,UAAY,SAAAC,GAC7B,IAAI+C,EAAS/C,EAAIc,OAAOC,OACpBgC,GACEA,EAAOP,MAAME,KAASF,GACxBK,EAAQG,KAAKD,EAAOP,QAEjBG,GAASE,EAAQI,QAAUN,EAC9BI,EAAOG,WAEPjB,EAAWY,IAGbZ,EAAWY,IAGRA,I,2CA8BYX,EAAUQ,EAAKF,EAAOP,EAAYU,GACrD,IAAIC,EAAQlD,KAAKF,GAAGuC,YAAY,CAACG,IAAWL,YAAYK,GACpDW,EAAU,GAEdD,EAAME,aAAa/C,UAAY,SAAAC,GAC7B,IAAI+C,EAAS/C,EAAIc,OAAOC,OACxB,GAAIgC,EAAQ,CACV,GAAqB,kBAAVP,GAAsBO,EAAOP,MAAME,KAASF,EACrDK,EAAQG,KAAKD,EAAOP,YAEpB,GAAqB,kBAAVA,EAAoB,CAC7B,IAAIW,GAAU,EACZC,EAAML,EAAOP,MAAME,GACrB,OAAQF,EAAMa,QACZ,IAAK,OACHF,EAAUC,EAAMZ,EAAMc,IACtB,MACF,IAAK,QACHH,EAAUC,GAAOZ,EAAMc,IACvB,MACF,IAAK,OACHH,EAAUC,EAAMZ,EAAMc,IACtB,MACF,IAAK,QACHH,EAAUC,GAAOZ,EAAMc,IACvB,MACF,IAAK,OACHH,EAAUC,IAAQZ,EAAMc,IACxB,MACF,IAAK,OACHH,EAAUX,EAAMc,IAAIC,KAAKH,GACzB,MACF,QACED,GAAU,EAGVA,GACFN,EAAQG,KAAKD,EAAOP,SAIrBG,GAASE,EAAQI,QAAUN,IAC9BI,EAAOG,gBAGTjB,EAAWY,Q,KAMJrD","file":"static/js/0.6a39691f.chunk.js","sourcesContent":["class db {\n  /**\n   *\n   * @param {String} databasename Name of the database to open\n   * Creates a database object with the name provided.\n   * Default name: todox-v1\n   */\n  constructor(databasename) {\n    //Database name\n    databasename = databasename || \"todox-v1\"\n\n    //Open the database\n    this.request = window.indexedDB.open(databasename)\n\n    //Handle some events\n    this.request.onsuccess = evt => {\n      if (this.isNew) {\n        try {\n          /**\n           * We import a script here so that we don't make useless requests even\n           * if this upgrade event is not fired.\n           *\n           * Here we create default initial data we would need for our files\n           */\n          import(\"./todo_template\").then(todo_template => {\n            ;[\"today\", \"bills\", \"shopping\", \"work\"].forEach(name => {\n              let instance = new todo_template.default.TodoList(\n                name,\n                () => {\n                  this.add(\"lists\", instance)\n                },\n                { id: name }\n              )\n            })\n          })\n        } catch (e) {\n          console.error(e)\n        }\n      }\n      this.db = evt.target.result\n      try {\n        this.onsuccess(evt)\n      } catch (e) {\n        console.warn(e)\n        console.log(\"[indexedDB] DB creation success\")\n      }\n    }\n    this.request.onerror = evt => {\n      try {\n        this.onerror(evt)\n      } catch (e) {\n        console.warn(e)\n        console.log(\"[indexedDB] Database error:\" + this.request.errorCode)\n      }\n    }\n    this.request.onupgradeneeded = evt => {\n      this.db = evt.target.result\n      this.objectStores = {}\n      this.isNew = true\n\n      //Create object stores\n      this.objectStores.lists = this.db.createObjectStore(\"lists\", {\n        keyPath: \"id\",\n      })\n      this.objectStores.tasks = this.db.createObjectStore(\"tasks\", {\n        keyPath: \"id\",\n      })\n      this.objectStores.meta = this.db.createObjectStore(\"meta\")\n\n      //Create search indexes\n      this.objectStores.lists.createIndex(\"name\", \"name\", { unique: true })\n      this.objectStores.tasks.createIndex(\"status\", \"status\", { unique: false })\n      this.objectStores.tasks.createIndex(\"parent\", \"parent\", { unique: false })\n      this.objectStores.tasks.createIndex(\"starred\", \"starred\", {\n        unique: false,\n      })\n    }\n  }\n\n  /**\n   *\n   * @param {String} objectStore\n   * @param {Object} data\n   * @param {Function} onerror\n   * @param {Function} onsuccess\n   *\n   * This function adds the object 'data' to the given objectStore.\n   *\n   * @returns {IDBRequest} The request event of objectStore.add method\n   */\n  add(objectStore, data, onerror, onsuccess) {\n    let transaction = this.db.transaction([objectStore], \"readwrite\")\n    transaction.onerrror =\n      onerror || (evt => console.log(\"[indexedDB] DB Add error: \" + evt))\n    transaction.oncomplete =\n      onsuccess || (evt => console.log(\"[indexedDB] Task success: \" + evt))\n\n    // Return the request object\n    return transaction.objectStore(objectStore).add(data)\n  }\n\n  /**\n   *\n   * @param {String} objStore\n   * @param {String} id\n   * @param {Function} onerror\n   * @param {Function} onsuccess\n   *\n   * Delete a entry in the given objectStore ith the given id.\n   *\n   * @returns {IDBRequest} The delete request\n   */\n  delete(objStore, id, onerror, onsuccess) {\n    let transaction = this.db.transaction([objStore], \"readwrite\")\n    transaction.onerrror =\n      onerror || (evt => console.log(\"[indexedDB] DB Remove error: \" + evt))\n    transaction.oncomplete =\n      onsuccess || (evt => console.log(\"[indexedDB] Task success: \" + evt))\n\n    // Return the request object\n    return transaction.objectStore(objStore).delete(id)\n  }\n\n  /**\n   *\n   * @param {String} objStore\n   * @param {String} id\n   * @param {Function} onerror\n   * @param {Function} onsuccess\n   *\n   * @returns {IDBRequest} The get request of the get function\n   */\n  get(objStore, id, onerror, onsuccess) {\n    let transaction = this.db.transaction([objStore], \"readwrite\")\n    transaction.onerrror =\n      onerror || (evt => console.log(\"[indexedDB] DB Get error: \" + evt))\n    transaction.oncomplete =\n      onsuccess || (evt => console.log(\"[indexedDB] Task success: \" + evt))\n\n    // Return the request object\n    return transaction.objectStore(objStore).get(id)\n  }\n\n  /**\n   *\n   * @param {String} objStore\n   * @param {String} id\n   * @param {Object} newData\n   * @param {Function} onsuccess\n   * @param {Function} onerror\n   *\n   * Updates the entry of given id with he new data\n   *\n   * @returns {IDBRequest} The update request\n   */\n  update(objStore, id, newData, onsuccess, onerror) {\n    let transaction = this.db.transaction([objStore], \"readwrite\")\n    transaction.onerrror =\n      onerror || (evt => console.log(\"[indexedDB] DB Update error: \" + evt))\n    transaction.oncomplete = evt =>\n      console.log(\"[indexedDB] Task success: \" + evt)\n\n    let objectStore = transaction.objectStore(objStore)\n    objectStore.get(id).onsuccess = evt => {\n      var data = evt.target.result\n      data = { ...data, ...newData, id }\n\n      objectStore.put(data).onsuccess = evt => {\n        if (onsuccess) onsuccess(evt)\n      }\n    }\n  }\n\n  /**\n   *\n   * @param {String} objStore\n   * @param {String} index\n   * @param {Sring} value\n   * @param {Function} onerror\n   * @param {Function} onsuccess\n   *\n   * Gets an entry by the index of the given value\n   *\n   * @returns {IDBRequest} Request of the get request\n   */\n  getByIndex(objStore, index, value, onerror, onsuccess) {\n    let transaction = this.db.transaction([objStore], \"readwrite\")\n    transaction.onerrror =\n      onerror || (evt => console.log(\"[indexedDB] DB Search error: \" + evt))\n    transaction.oncomplete =\n      onsuccess || (evt => console.log(\"[indexedDB] Task success: \" + evt))\n\n    return transaction.objectStore(objStore).index(index).get(value)\n  }\n  /**\n   *\n   * @param {String} objStore\n   * @param {string} index\n   * @param {string} value\n   * @param {Function} onsuccess\n   * @param {Function} onerror\n   *\n   * Get all the docs that are there in the given objectStore,\n   * filtered by the value\n   */\n  getAllByIndex(objStore, index, value, onsuccess, onerror) {\n    let transaction = this.db.transaction([objStore], \"readwrite\")\n    transaction.onerrror =\n      onerror || (evt => console.log(\"[indexedDB] DB Search error: \" + evt))\n    transaction.oncomplete =\n      onsuccess || (evt => console.log(\"[indexedDB] Task success: \" + evt))\n\n    return transaction.objectStore(objStore).index(index).getAll(value)\n  }\n\n  /**\n   *\n   * @param {String} objStore\n   * @param {String} key\n   * @param {String} value\n   * @param {Number} limit\n   *\n   * Returns an array of all the entries in `objStore`\n   * with the same key:value pair as given.\n   *\n   * Limit is a number that defines the max number of entries to find\n   *\n   * @returns {Array}\n   */\n  getMultipleByKey(objStore, key, value, oncomplete, limit) {\n    let store = this.db.transaction([objStore]).objectStore(objStore)\n    let matched = []\n\n    store.openCursor().onsuccess = evt => {\n      var cursor = evt.target.result\n      if (cursor) {\n        if (cursor.value[key] === value) {\n          matched.push(cursor.value)\n        }\n        if (!limit || matched.length <= limit) {\n          cursor.continue()\n        } else {\n          oncomplete(matched)\n        }\n      } else {\n        oncomplete(matched)\n      }\n    }\n    return matched\n  }\n\n  /**\n   *\n   * @param {String} objStore\n   * @param {String} key\n   * @param {String} value\n   * @param {Function} oncomplete\n   * @param {Number} limit\n   *\n   * Finds all the entries in the given objectStore but this\n   * time, the value is not the exact value but the filters you want\n   * to match the entries with.\n   *\n   * Supported filters:\n   *\n   * - __lt: Less than a certain value\n   * - __lte: Less than or equal to given value\n   * - __gt: Greater than given value\n   * - __gte: Greater than or equal than given value\n   * - __re: A Regular Expression to match the entries.\n   * - __ne: Not equal to given value.\n   *\n   * Example: getMultipleByFilters(\"employees\", \"salary\", {filter: \"__gt\", val: 4000})\n   *  will return all entries in the objectStore \"employees\" which have\n   * the property \"salary\" set to above 4000.\n   *\n   * @returns {undefined}\n   */\n  getMultipleByFilters(objStore, key, value, oncomplete, limit) {\n    let store = this.db.transaction([objStore]).objectStore(objStore)\n    let matched = []\n\n    store.openCursor().onsuccess = evt => {\n      var cursor = evt.target.result\n      if (cursor) {\n        if (typeof value !== \"object\" && cursor.value[key] === value) {\n          matched.push(cursor.value)\n        } else {\n          if (typeof value === \"object\") {\n            let matches = false,\n              ref = cursor.value[key]\n            switch (value.filter) {\n              case \"__lt\":\n                matches = ref < value.val\n                break\n              case \"__lte\":\n                matches = ref <= value.val\n                break\n              case \"__gt\":\n                matches = ref > value.val\n                break\n              case \"__gte\":\n                matches = ref >= value.val\n                break\n              case \"__ne\":\n                matches = ref !== value.val\n                break\n              case \"__re\":\n                matches = value.val.test(ref)\n                break\n              default:\n                matches = false\n                break\n            }\n            if (matches) {\n              matched.push(cursor.value)\n            }\n          }\n        }\n        if (!limit || matched.length <= limit) {\n          cursor.continue()\n        }\n      } else {\n        oncomplete(matched)\n      }\n    }\n  }\n}\n\nexport default db\n"],"sourceRoot":""}